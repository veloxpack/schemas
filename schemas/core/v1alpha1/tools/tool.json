{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://schemas.veloxpack.io/schemas/core/v1alpha1/tools/tool.json",
  "title": "Tool",
  "description": "ToolSpec defines the desired state of Tool.\nTool resources define containerized media processing utilities (FFmpeg, Shaka Packager,\nImageMagick, etc.) that are used in Veloxpack workflows for transcoding, packaging,\nthumbnail generation, and other media operations. Each tool runs as a container\nwith configurable entrypoints, environment, and validation checks.",
  "properties": {
    "args": {
      "description": "Args provides default arguments passed to the command.\nThese can be overridden by individual job/workflow steps.\nUse for setting common flags like \"-hide_banner\" for FFmpeg.\nExample: [\"-hide_banner\", \"-loglevel\", \"info\"]",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "command": {
      "description": "Command overrides the container's default ENTRYPOINT.\nUse when the default entrypoint is not suitable for Veloxpack's execution model.\nLeave empty to use the image's default entrypoint.\nExample: [\"/usr/local/bin/ffmpeg\"] or [\"/bin/sh\", \"-c\"]",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "env": {
      "description": "Env defines environment variables for the tool container.\nUseful for configuring tool behavior, licensing, or feature flags.\nExamples:\n- FFMPEG_DATADIR=/usr/share/ffmpeg\n- LD_LIBRARY_PATH=/usr/local/lib\n- LICENSE_KEY=... (for commercial encoders)\nCan reference ConfigMaps and Secrets using valueFrom.",
      "items": {
        "description": "EnvVar represents an environment variable present in a Container.",
        "properties": {
          "name": {
            "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
            "type": "string"
          },
          "value": {
            "description": "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".",
            "type": "string"
          },
          "valueFrom": {
            "description": "Source for the environment variable's value. Cannot be used if value is not empty.",
            "properties": {
              "configMapKeyRef": {
                "description": "Selects a key of a ConfigMap.",
                "properties": {
                  "key": {
                    "description": "The key to select.",
                    "type": "string"
                  },
                  "name": {
                    "default": "",
                    "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "optional": {
                    "description": "Specify whether the ConfigMap or its key must be defined",
                    "type": "boolean"
                  }
                },
                "required": [
                  "key"
                ],
                "type": "object",
                "x-kubernetes-map-type": "atomic",
                "additionalProperties": false
              },
              "fieldRef": {
                "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.",
                "properties": {
                  "apiVersion": {
                    "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                    "type": "string"
                  },
                  "fieldPath": {
                    "description": "Path of the field to select in the specified API version.",
                    "type": "string"
                  }
                },
                "required": [
                  "fieldPath"
                ],
                "type": "object",
                "x-kubernetes-map-type": "atomic",
                "additionalProperties": false
              },
              "resourceFieldRef": {
                "description": "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.",
                "properties": {
                  "containerName": {
                    "description": "Container name: required for volumes, optional for env vars",
                    "type": "string"
                  },
                  "divisor": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                    "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                    "x-kubernetes-int-or-string": true
                  },
                  "resource": {
                    "description": "Required: resource to select",
                    "type": "string"
                  }
                },
                "required": [
                  "resource"
                ],
                "type": "object",
                "x-kubernetes-map-type": "atomic",
                "additionalProperties": false
              },
              "secretKeyRef": {
                "description": "Selects a key of a secret in the pod's namespace",
                "properties": {
                  "key": {
                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                    "type": "string"
                  },
                  "name": {
                    "default": "",
                    "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "optional": {
                    "description": "Specify whether the Secret or its key must be defined",
                    "type": "boolean"
                  }
                },
                "required": [
                  "key"
                ],
                "type": "object",
                "x-kubernetes-map-type": "atomic",
                "additionalProperties": false
              }
            },
            "type": "object",
            "additionalProperties": false
          }
        },
        "required": [
          "name"
        ],
        "type": "object",
        "additionalProperties": false
      },
      "type": "array"
    },
    "envFrom": {
      "description": "EnvFrom imports environment variables from ConfigMaps or Secrets.\nUseful for bulk configuration or managing multiple related variables.\nExample: Import all variables from a ConfigMap named \"encoder-config\"",
      "items": {
        "description": "EnvFromSource represents the source of a set of ConfigMaps or Secrets",
        "properties": {
          "configMapRef": {
            "description": "The ConfigMap to select from",
            "properties": {
              "name": {
                "default": "",
                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                "type": "string"
              },
              "optional": {
                "description": "Specify whether the ConfigMap must be defined",
                "type": "boolean"
              }
            },
            "type": "object",
            "x-kubernetes-map-type": "atomic",
            "additionalProperties": false
          },
          "prefix": {
            "description": "Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.",
            "type": "string"
          },
          "secretRef": {
            "description": "The Secret to select from",
            "properties": {
              "name": {
                "default": "",
                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                "type": "string"
              },
              "optional": {
                "description": "Specify whether the Secret must be defined",
                "type": "boolean"
              }
            },
            "type": "object",
            "x-kubernetes-map-type": "atomic",
            "additionalProperties": false
          }
        },
        "type": "object",
        "additionalProperties": false
      },
      "type": "array"
    },
    "image": {
      "description": "Image specifies the container image for this tool.\nShould include registry, repository, and tag for reproducibility.\nExamples:\n- \"jrottenberg/ffmpeg:6.0-alpine\" (FFmpeg for transcoding)\n- \"google/shaka-packager:v2.6.1\" (Shaka Packager for DASH/HLS)\n- \"dpokidov/imagemagick:7.1.1\" (ImageMagick for thumbnails)\n- \"gcr.io/my-project/custom-encoder:v1.2.3\" (Custom tool)\nUse specific tags rather than \"latest\" for production stability.",
      "minLength": 1,
      "type": "string"
    },
    "imagePullPolicy": {
      "default": "IfNotPresent",
      "description": "ImagePullPolicy determines when Kubernetes should pull the container image.\n- IfNotPresent: Pull only if not already present on the node (default, recommended)\n- Always: Always pull the image, useful for \"latest\" tags or frequent updates\n- Never: Never pull, image must already exist on the node",
      "type": "string"
    },
    "imagePullSecrets": {
      "description": "ImagePullSecrets references secrets containing credentials for private registries.\nRequired when using private container registries (GCR, ECR, ACR, Docker Hub private).\nEach secret should be of type kubernetes.io/dockerconfigjson.\nExample: [{\"name\": \"gcr-credentials\"}, {\"name\": \"dockerhub-secret\"}]",
      "items": {
        "description": "LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.",
        "properties": {
          "name": {
            "default": "",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "type": "string"
          }
        },
        "type": "object",
        "x-kubernetes-map-type": "atomic",
        "additionalProperties": false
      },
      "type": "array"
    },
    "labels": {
      "additionalProperties": {
        "type": "string"
      },
      "description": "Labels are arbitrary key-value pairs for categorizing and selecting tools.\nExamples: {\"hardware\": \"gpu\", \"codec\": \"h265\", \"vendor\": \"nvidia\"}\nCan be used in WorkflowTemplates for tool selection logic.",
      "type": "object"
    },
    "priority": {
      "default": 0,
      "description": "Priority determines tool selection when multiple tools provide the same capability.\nHigher priority tools are preferred over lower priority ones.\nUse cases:\n- Prefer GPU-accelerated FFmpeg (priority: 90) over CPU-only (priority: 50)\n- Prefer licensed commercial encoder (priority: 100) over open-source (priority: 50)\n- Prefer newer tool versions over older ones\n- Canary deployments: new tool at lower priority for gradual rollout\nRange: 0-100, where 0 is lowest priority and 100 is highest.\nDefault: 0 (equal priority, selection may be arbitrary)",
      "format": "int32",
      "maximum": 100,
      "minimum": 0,
      "type": "integer"
    },
    "securityContext": {
      "description": "SecurityContext defines privilege and access control settings for the container.\nMay be required for:\n- Hardware access (privileged: true for GPU/video devices)\n- Running as specific user/group for file permissions\n- Capabilities (CAP_SYS_ADMIN for certain operations)\n- Read-only root filesystem (readOnlyRootFilesystem: true) for security\nExample: {privileged: true} for GPU access or {runAsUser: 1000} for non-root",
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "AllowPrivilegeEscalation controls whether a process can gain more\nprivileges than its parent process. This bool directly controls if\nthe no_new_privs flag will be set on the container process.\nAllowPrivilegeEscalation is true always when the container is:\n1) run as Privileged\n2) has CAP_SYS_ADMIN\nNote that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "appArmorProfile": {
          "description": "appArmorProfile is the AppArmor options to use by this container. If set, this profile\noverrides the pod's appArmorProfile.\nNote that this field cannot be set when spec.os.name is windows.",
          "properties": {
            "localhostProfile": {
              "description": "localhostProfile indicates a profile loaded on the node that should be used.\nThe profile must be preconfigured on the node to work.\nMust match the loaded name of the profile.\nMust be set if and only if type is \"Localhost\".",
              "type": "string"
            },
            "type": {
              "description": "type indicates which kind of AppArmor profile will be applied.\nValid options are:\n  Localhost - a profile pre-loaded on the node.\n  RuntimeDefault - the container runtime's default profile.\n  Unconfined - no AppArmor enforcement.",
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object",
          "additionalProperties": false
        },
        "capabilities": {
          "description": "The capabilities to add/drop when running containers.\nDefaults to the default set of capabilities granted by the container runtime.\nNote that this field cannot be set when spec.os.name is windows.",
          "properties": {
            "add": {
              "description": "Added capabilities",
              "items": {
                "description": "Capability represent POSIX capabilities type",
                "type": "string"
              },
              "type": "array",
              "x-kubernetes-list-type": "atomic"
            },
            "drop": {
              "description": "Removed capabilities",
              "items": {
                "description": "Capability represent POSIX capabilities type",
                "type": "string"
              },
              "type": "array",
              "x-kubernetes-list-type": "atomic"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "privileged": {
          "description": "Run container in privileged mode.\nProcesses in privileged containers are essentially equivalent to root on the host.\nDefaults to false.\nNote that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "procMount": {
          "description": "procMount denotes the type of proc mount to use for the containers.\nThe default value is Default which uses the container runtime defaults for\nreadonly paths and masked paths.\nThis requires the ProcMountType feature flag to be enabled.\nNote that this field cannot be set when spec.os.name is windows.",
          "type": "string"
        },
        "readOnlyRootFilesystem": {
          "description": "Whether this container has a read-only root filesystem.\nDefault is false.\nNote that this field cannot be set when spec.os.name is windows.",
          "type": "boolean"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.",
          "format": "int64",
          "type": "integer"
        },
        "runAsNonRoot": {
          "description": "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "boolean"
        },
        "runAsUser": {
          "description": "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.",
          "format": "int64",
          "type": "integer"
        },
        "seLinuxOptions": {
          "description": "The SELinux context to be applied to the container.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.",
          "properties": {
            "level": {
              "description": "Level is SELinux level label that applies to the container.",
              "type": "string"
            },
            "role": {
              "description": "Role is a SELinux role label that applies to the container.",
              "type": "string"
            },
            "type": {
              "description": "Type is a SELinux type label that applies to the container.",
              "type": "string"
            },
            "user": {
              "description": "User is a SELinux user label that applies to the container.",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        },
        "seccompProfile": {
          "description": "The seccomp options to use by this container. If seccomp options are\nprovided at both the pod & container level, the container options\noverride the pod options.\nNote that this field cannot be set when spec.os.name is windows.",
          "properties": {
            "localhostProfile": {
              "description": "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.",
              "type": "string"
            },
            "type": {
              "description": "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.",
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object",
          "additionalProperties": false
        },
        "windowsOptions": {
          "description": "The Windows specific settings applied to all containers.\nIf unspecified, the options from the PodSecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.",
          "properties": {
            "gmsaCredentialSpec": {
              "description": "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.",
              "type": "string"
            },
            "gmsaCredentialSpecName": {
              "description": "GMSACredentialSpecName is the name of the GMSA credential spec to use.",
              "type": "string"
            },
            "hostProcess": {
              "description": "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.",
              "type": "boolean"
            },
            "runAsUserName": {
              "description": "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.",
              "type": "string"
            }
          },
          "type": "object",
          "additionalProperties": false
        }
      },
      "type": "object",
      "additionalProperties": false
    },
    "validationCommand": {
      "description": "ValidationCommand is executed to verify the tool is functioning correctly.\nShould be a simple, fast command that exits with code 0 when the tool is operational.\nUsed during tool registration and periodic health checks.\nVersion information may be extracted from command output for status display.\nExamples:\n- [\"ffmpeg\", \"-version\"] \u2192 verifies FFmpeg and extracts version\n- [\"packager\", \"--version\"] \u2192 verifies Shaka Packager\n- [\"convert\", \"-version\"] \u2192 verifies ImageMagick\n- [\"python\", \"-c\", \"import cv2; print(cv2.__version__)\"] \u2192 Python library check\nIf omitted, tool is assumed ready without validation (not recommended).",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "volumeDevices": {
      "description": "VolumeDevices maps block devices into the container for direct hardware access.\nRequired for accessing:\n- Video capture devices: /dev/video0, /dev/video1 (webcams, capture cards)\n- GPU devices: /dev/dri/renderD128 (Intel QSV), /dev/nvidia0 (NVIDIA)\n- Audio devices: /dev/snd/* (ALSA sound devices)\nExample: [{name: \"video0\", devicePath: \"/dev/video0\"}]\nHost devices must be made available through DaemonSet or node configuration.",
      "items": {
        "description": "volumeDevice describes a mapping of a raw block device within a container.",
        "properties": {
          "devicePath": {
            "description": "devicePath is the path inside of the container that the device will be mapped to.",
            "type": "string"
          },
          "name": {
            "description": "name must match the name of a persistentVolumeClaim in the pod",
            "type": "string"
          }
        },
        "required": [
          "devicePath",
          "name"
        ],
        "type": "object",
        "additionalProperties": false
      },
      "type": "array"
    },
    "volumeMounts": {
      "description": "VolumeMounts specifies filesystem paths where volumes should be mounted.\nCommon use cases:\n- Shared storage for input/output media files\n- Configuration files (encoder presets, font files)\n- Temporary workspace for multi-stage processing\n- License files for commercial tools\nExample: [{name: \"media-storage\", mountPath: \"/media\"}]",
      "items": {
        "description": "VolumeMount describes a mounting of a Volume within a container.",
        "properties": {
          "mountPath": {
            "description": "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.",
            "type": "string"
          },
          "mountPropagation": {
            "description": "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).",
            "type": "string"
          },
          "name": {
            "description": "This must match the Name of a Volume.",
            "type": "string"
          },
          "readOnly": {
            "description": "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.",
            "type": "boolean"
          },
          "recursiveReadOnly": {
            "description": "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.",
            "type": "string"
          },
          "subPath": {
            "description": "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).",
            "type": "string"
          },
          "subPathExpr": {
            "description": "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.",
            "type": "string"
          }
        },
        "required": [
          "mountPath",
          "name"
        ],
        "type": "object",
        "additionalProperties": false
      },
      "type": "array"
    },
    "workingDir": {
      "description": "WorkingDir sets the container's working directory for command execution.\nIf not specified, uses the container runtime's default (often root \"/\" or image WORKDIR).\nUseful when tools expect to run from specific directories.\nExample: \"/workspace\", \"/tmp\"",
      "type": "string"
    }
  },
  "required": [
    "image"
  ],
  "type": "object",
  "x-kubernetes-validations": [
    {
      "message": "priority must be between 0 and 100",
      "rule": "self.priority >= 0 && self.priority <= 100"
    },
    {
      "message": "image must be specified",
      "rule": "size(self.image) > 0"
    }
  ]
}
